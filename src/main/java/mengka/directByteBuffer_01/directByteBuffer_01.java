package mengka.directByteBuffer_01;

/**
 * 堆外内存：
 * 堆外内存是存在于JVM管控之外的一块内存区域，因此它是不受JVM的管控；
 *
 * 堆内内存：
 * 由JVM所管控的Java进程内存，我们平时在Java中创建的对象都处于堆内内存中；
 * JVM会采用垃圾回收机制统一管理它们的内存；
 *
 * 【例①】：
 * 比如我们要完成一个从文件中读数据到堆内内存的操作，即FileChannelImpl.read(HeapByteBuffer)。
 * 这里实际上File I/O会将数据读到堆外内存中，然后堆外内存再讲数据拷贝到堆内内存，这样我们就读到了文件中的内存。
 *
 * 【例②】：
 * 直接使用堆外内存，如DirectByteBuffer：这种方式是直接在堆外分配一个内存(即，native memory)来存储数据，
 * 程序通过JNI直接将数据读/写到堆外内存中。
 *
 * 【什么情况下使用堆外内存？】
 * 1.堆外内存适用于生命周期中等或较长的对象。( 如果是生命周期较短的对象，在YGC的时候就被回收了，就不存在大内存且生命周期较长的对象在FGC对应用造成的性能影响 )
 * 2.直接的文件拷贝操作，或者I/O操作。直接使用堆外内存就能少去内存从用户内存拷贝到系统内存的操作，因为I/O操作是系统内核内存和设备间的通信，而不是通过程序直接和外设通信的;
 * 3.同时，还可以使用"池+堆外内存"的组合方式，来对生命周期较短，但涉及到I/O操作的对象进行堆外内存的再使用。( Netty中就使用了该方式 )
 *
 * 》》内存池往往适用于生命期较短的可变对象，而堆外内存适用于生命期中等或较长的对象；
 *
 * 》》堆外内存的特点：
 * 1.对于大内存有良好的伸缩性;
 * 2.对垃圾回收停顿的改善可以明显感觉到;
 * 3.在进程间可以共享，减少虚拟机间的复制;
 *
 * @author mengka
 * @date 2017/08/28.
 */
public class directByteBuffer_01 {

    public static void main(String[] args){

    }
}
